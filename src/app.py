import json, os, datetime
from typing import Dict, Any, List

# =========================
# CAP. 3 — SUBALGORITMOS
# =========================

def input_int(prompt: str, min_val: int = None, max_val: int = None) -> int:
    while True:
        try:
            v = int(input(prompt).strip())
            if min_val is not None and v < min_val:
                print(f"Valor deve ser >= {min_val}.")
                continue
            if max_val is not None and v > max_val:
                print(f"Valor deve ser <= {max_val}.")
                continue
            return v
        except ValueError:
            print("Digite um número inteiro válido.")

def input_float(prompt: str, min_val: float = None, max_val: float = None) -> float:
    while True:
        try:
            v = float(input(prompt).replace(",", ".").strip())
            if min_val is not None and v < min_val:
                print(f"Valor deve ser >= {min_val}.")
                continue
            if max_val is not None and v > max_val:
                print(f"Valor deve ser <= {max_val}.")
                continue
            return v
        except ValueError:
            print("Digite um número decimal válido (use . ou ,).")

def input_nonempty(prompt: str) -> str:
    while True:
        v = input(prompt).strip()
        if v:
            return v
        print("Campo obrigatório.")

# =========================
# CAP. 4 — ESTRUTURAS
# =========================
# Tabela de memória: dicionário de talhões e lista de operações
db_mem = {
    "talhoes": {},         # id_talhao -> dict
    "operacoes": []        # lista de dicts
}

def gerar_id_talhao(db: Dict[str, Any]) -> int:
    # IDs inteiros incrementais
    return (max(map(int, db["talhoes"].keys())) + 1) if db["talhoes"] else 1

# =========================
# CAP. 5 — JSON + TXT
# =========================
DATA_JSON = "dados.json"

def salvar_json(caminho: str, dados: Dict[str, Any]) -> None:
    with open(caminho, "w", encoding="utf-8") as f:
        json.dump(dados, f, ensure_ascii=False, indent=2)

def carregar_json(caminho: str) -> Dict[str, Any]:
    if not os.path.exists(caminho):
        return {"talhoes": {}, "operacoes": []}
    with open(caminho, "r", encoding="utf-8") as f:
        return json.load(f)

def exportar_relatorio_txt(db: Dict[str, Any], caminho: str = "relatorio.txt") -> None:
    # estatísticas simples (Cap. 7 )
    total_ops = len(db["operacoes"])
    perdas = [op["perda_percent"] for op in db["operacoes"]] or [0.0]
    media_perda = sum(perdas) / len(perdas)
    total_peso = sum(op["peso_t_colhido"] for op in db["operacoes"]) if db["operacoes"] else 0.0
    with open(caminho, "w", encoding="utf-8") as f:
        f.write("RELATÓRIO DE COLHEITA DE CANA\n")
        f.write(f"Data: {datetime.datetime.now()}\n\n")
        f.write(f"Total de operações: {total_ops}\n")
        f.write(f"Peso total colhido (t): {total_peso:.2f}\n")
        f.write(f"Média de perda estimada (%): {media_perda:.2f}\n\n")
        f.write("Operações:\n")
        for op in db["operacoes"]:
            f.write(
                f"- {op['data']} | Talhão {op['id_talhao']} ({db['talhoes'].get(str(op['id_talhao']),{}).get('nome','?')}) "
                f"| Peso {op['peso_t_colhido']} t | Perda {op['perda_percent']}%\n"
            )
    print(f"Relatório exportado em: {os.path.abspath(caminho)}")

# =========================
# CAP. 6 — ORACLE (AINDA FALTA EDITAR**************************)
# =========================
# CONFIGURAR antes de usar:
#   pip install oracledb
#   Defina variáveis de ambiente:
#     ORA_DSN="host:1521/servicename"
#     ORA_USER="usuario"
#     ORA_PASS="senha"
def oracle_enabled() -> bool:
    return all(k in os.environ for k in ["ORA_DSN", "ORA_USER", "ORA_PASS"])

def oracle_conn():
    import oracledb
    return oracledb.connect(
        user=os.environ["ORA_USER"],
        password=os.environ["ORA_PASS"],
        dsn=os.environ["ORA_DSN"]
    )

DDL_TALHOES = """
CREATE TABLE talhoes (
  id_talhao NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome VARCHAR2(100) NOT NULL,
  area_ha NUMBER(10,2) NOT NULL
)
"""

DDL_OPERACOES = """
CREATE TABLE operacoes (
  id_op NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_talhao NUMBER NOT NULL REFERENCES talhoes(id_talhao),
  data_op DATE NOT NULL,
  peso_t_colhido NUMBER(12,2) NOT NULL,
  perda_percent NUMBER(5,2) NOT NULL
)
"""

def oracle_criar_tabelas():
    try:
        with oracle_conn() as con, con.cursor() as cur:
            for ddl in (DDL_TALHOES, DDL_OPERACOES):
                try:
                    cur.execute(ddl)
                except Exception as e:
                    # ignora se já existem
                    if "ORA-00955" not in str(e):
                        raise
        print("Tabelas conferidas/criadas.")
    except Exception as e:
        print(f"[Oracle] Erro criando tabelas: {e}")

def oracle_inserir_talhao(nome: str, area_ha: float) -> int:
    try:
        with oracle_conn() as con, con.cursor() as cur:
            cur.execute("INSERT INTO talhoes(nome, area_ha) VALUES (:1, :2) RETURNING id_talhao INTO :id",
                        [nome, area_ha, cur.var(int)])
            new_id = cur.getimplicitresults()[0][0] if cur.getimplicitresults() else None
            con.commit()
            return int(new_id) if new_id is not None else -1
    except Exception as e:
        print(f"[Oracle] Erro inserindo talhão: {e}")
        return -1

def oracle_listar_talhoes() -> List[Dict[str, Any]]:
    try:
        with oracle_conn() as con, con.cursor() as cur:
            cur.execute("SELECT id_talhao, nome, area_ha FROM talhoes ORDER BY id_talhao")
            return [{"id_talhao": r[0], "nome": r[1], "area_ha": float(r[2])} for r in cur]
    except Exception as e:
        print(f"[Oracle] Erro listando talhões: {e}")
        return []

def oracle_inserir_operacao(id_talhao: int, data_op: str, peso_t: float, perda_pct: float) -> None:
    try:
        with oracle_conn() as con, con.cursor() as cur:
            cur.execute(
                "INSERT INTO operacoes(id_talhao, data_op, peso_t_colhido, perda_percent) "
                "VALUES (:1, TO_DATE(:2,'YYYY-MM-DD'), :3, :4)",
                [id_talhao, data_op, peso_t, perda_pct]
            )
            con.commit()
    except Exception as e:
        print(f"[Oracle] Erro inserindo operação: {e}")

def oracle_listar_operacoes() -> List[Dict[str, Any]]:
    try:
        with oracle_conn() as con, con.cursor() as cur:
            cur.execute(
                "SELECT id_op, id_talhao, TO_CHAR(data_op,'YYYY-MM-DD'), peso_t_colhido, perda_percent "
                "FROM operacoes ORDER BY id_op"
            )
            return [{
                "id_op": r[0],
                "id_talhao": r[1],
                "data": r[2],
                "peso_t_colhido": float(r[3]),
                "perda_percent": float(r[4])
            } for r in cur]
    except Exception as e:
        print(f"[Oracle] Erro listando operações: {e}")
        return []

# ================
# LÓGICA (Cap. 2)
# ================

def perda_alerta(perda_percent: float) -> str:
    # Heurística simples: alerta por faixas
    if perda_percent >= 15:
        return "ALTA (investigar regulagem da colhedora, velocidade de avanço, altura de corte)"
    if perda_percent >= 8:
        return "MÉDIA (rever umidade e terreno, checar facas)"
    return "BAIXA (dentro do esperado)"

# =========================
# MENU/CRUD em memória
# =========================

def menu():
    print("\n=== GESTÃO DE COLHEITA DE CANA ===")
    print("1) Cadastrar talhão")
    print("2) Listar talhões")
    print("3) Registrar operação de colheita")
    print("4) Listar operações")
    print("5) Exportar relatório .txt")
    print("6) Salvar JSON")
    print("7) Carregar JSON")
    print("8) Oracle: criar tabelas (opcional)")
    print("9) Oracle: sincronizar MEM -> Oracle (opcional)")
    print("0) Sair")

def cadastrar_talhao():
    nome = input_nonempty("Nome do talhão: ")
    area = input_float("Área (ha): ", min_val=0.1)
    new_id = gerar_id_talhao(db_mem)
    db_mem["talhoes"][str(new_id)] = {"id_talhao": new_id, "nome": nome, "area_ha": area}
    print(f"Talhão {new_id} criado.")

def listar_talhoes():
    if not db_mem["talhoes"]:
        print("Nenhum talhão cadastrado.")
        return
    print("ID | Nome | Área (ha)")
    for tid, t in db_mem["talhoes"].items():
        print(f"{t['id_talhao']:>2} | {t['nome']} | {t['area_ha']}")

def registrar_operacao():
    if not db_mem["talhoes"]:
        print("Cadastre talhões antes.")
        return
    listar_talhoes()
    id_t = input_int("ID do talhão: ", min_val=1)
    if str(id_t) not in db_mem["talhoes"]:
        print("Talhão inexistente.")
        return
    data_str = input_nonempty("Data (YYYY-MM-DD): ")
    peso = input_float("Peso colhido (t): ", min_val=0.0)
    perda = input_float("Perda estimada (%): ", min_val=0.0, max_val=100.0)
    op = {
        "id_op": len(db_mem["operacoes"]) + 1,
        "id_talhao": id_t,
        "data": data_str,
        "peso_t_colhido": peso,
        "perda_percent": perda,
        "alerta_perda": perda_alerta(perda)
    }
    db_mem["operacoes"].append(op)
    print(f"Operação registrada. Alerta de perda: {op['alerta_perda']}")

def listar_operacoes():
    if not db_mem["operacoes"]:
        print("Nenhuma operação registrada.")
        return
    print("ID | Data | Talhão | Peso(t) | Perda(%) | Alerta")
    for op in db_mem["operacoes"]:
        t = db_mem["talhoes"].get(str(op["id_talhao"]), {})
        print(f"{op['id_op']:>2} | {op['data']} | {op['id_talhao']}({t.get('nome','?')}) | "
              f"{op['peso_t_colhido']:.2f} | {op['perda_percent']:.2f} | {op['alerta_perda']}")

def sincronizar_mem_para_oracle():
    if not oracle_enabled():
        print("Defina ORA_DSN / ORA_USER / ORA_PASS nas variáveis de ambiente.")
        return
    oracle_criar_tabelas()
    # Insere talhões que não existem (lógica simples; em produção, faria upsert)
    existentes = {t["id_talhao"] for t in oracle_listar_talhoes()}
    for tid, t in db_mem["talhoes"].items():
        if t["id_talhao"] not in existentes:
            novo_id = oracle_inserir_talhao(t["nome"], float(t["area_ha"]))
            if novo_id == -1:
                print(f"Falha ao inserir talhão {tid} no Oracle.")
    # Insere operações
    ops_oracle = oracle_listar_operacoes()
    chave_oracle = {(o["id_talhao"], o["data"], o["peso_t_colhido"], o["perda_percent"]) for o in ops_oracle}
    for op in db_mem["operacoes"]:
        chave = (op["id_talhao"], op["data"], float(op["peso_t_colhido"]), float(op["perda_percent"]))
        if chave not in chave_oracle:
            oracle_inserir_operacao(*chave)
    print("Sincronização concluída.")

def main():
    # carrega dados de disco (se existirem)
    global db_mem
    db_mem = carregar_json(DATA_JSON)
    while True:
        menu()
        op = input_nonempty("Escolha: ")
        if op == "1":
            cadastrar_talhao()
        elif op == "2":
            listar_talhoes()
        elif op == "3":
            registrar_operacao()
        elif op == "4":
            listar_operacoes()
        elif op == "5":
            exportar_relatorio_txt(db_mem)
        elif op == "6":
            salvar_json(DATA_JSON, db_mem)
            print(f"Salvo em {DATA_JSON}.")
        elif op == "7":
            db = carregar_json(DATA_JSON)
            if isinstance(db, dict) and "talhoes" in db and "operacoes" in db:
                db_mem.update(db)
                print("JSON carregado na memória.")
            else:
                print("JSON inválido.")
        elif op == "8":
            if oracle_enabled():
                oracle_criar_tabelas()
            else:
                print("Configure ORA_* para usar Oracle.")
        elif op == "9":
            sincronizar_mem_para_oracle()
        elif op == "0":
            print("Até mais!")
            break
        else:
            print("Opção inválida.")

if __name__ == "__main__":
    main()